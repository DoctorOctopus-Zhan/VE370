# VE370 Introduction to Computer Organization

<center><b>Project 1</b></center>
<center>Wu Jiayao,吴佳遥,517370910257</center>
## 1. Obejective

Develop a MIPS assembly program that operates on a data segment consisting of an array of 32-bit signed integers. 

For this project, the MIPS program is developed from a C program that counts the number of positive integers, negative integers and 0 from an customized array whose size is more than 20.

## 2. Arrangement of the registers

| Name | Usage                                                        | Name | Usage                                       |
| ---- | ------------------------------------------------------------ | ---- | ------------------------------------------- |
| t0   | register for delay operations                                | a0   | The first arg of a function: numArray; A[i] |
| t1   | CntType                                                      | a1   | The second arg of a function: numElements   |
| t2   | register for temporarily storage                             | a2   | The third arg of a function:cntType         |
| t3   | i in countArray(int*,int,int)                                | s0   | int size = 21 for this work                 |
| t4   | register for storing bool temps in Pos(int),Neg(int),Zero(int) | s1   | int PosCnt                                  |
| t5   | numArray[i]                                                  | s2   | int NegCnt                                  |
| t9   | cnt in countArray(int*,int,int)                              | s3   | int ZeroCnt                                 |

## 3. Project Customization and Comments

- Detail comments follows the source code in Appendix.

- The array for this project is generated by Python. Given as [14 -15 0 -13 -8 16 30 -38 24 0 18 14 -30 -13 -2 17 0 -27 11 -30 25]. Source code is provided in Appendix.

- For this project:

  ~~~c
  int size =21;
  //Result
  PosCnt = 9;
  NegCnt = 9;
  ZeroCnt = 3;
  ~~~

## 4. Before calling countArray(int*,int,int)

~~~c
int main() 
{
    int size = 21; //determine the size of the array here
    int PosCnt, NegCnt, ZeroCnt;
    int testArray[21] = { 14,-15,0,-13,-8,16,30,-38,24,0,18,14,-30,-13,-2,17,0,-27,11,-30,25};
    ....
}

~~~

![1569604379598](D:\OneDrive - sjtu.edu.cn\JI\2019FA\VE370\PROJECT1\1569604379598.png)

Line 4 to Line 52 in project1.s.

The testArray is stored in 0-80th address of the stack $\$sp$. 

size is stored in $\$s0$.

PosCnt is stored in $\$s1$. 

NegInt is stored in $\$s2$.

ZeroCnt is stored in $\$s3$

## 5. Inside countArray(int*,int,int)

### 5.1 Function and For loop initialization

Save the return address $\$ra$ into the stack to make sure a correct return.

![1569606319774](D:\OneDrive - sjtu.edu.cn\JI\2019FA\VE370\PROJECT1\1569606319774.png)

~~~c
int i, cnt = 0;
for (i = numElements - 1; i >= 0; i--)
{
    ...
}
~~~

![1569606592985](D:\OneDrive - sjtu.edu.cn\JI\2019FA\VE370\PROJECT1\1569606592985.png)

Line 77 to Line 81 in project1.s..

Save the return address into the stack, the 84 address.

Set from arguments $ numElements $ in $\$t0$ and $cntType$ in  $\$t1$.

Set the iterator of the for loop in $\$ t3$.

Set the result variable in register $\$t9$.

At the beginning of each loop, if i<0, it will jump to the end of loop also end of the function (see 5.5).

### 5.2 Operation inside loop

![1569607640860](D:\OneDrive - sjtu.edu.cn\JI\2019FA\VE370\PROJECT1\1569607640860.png)

i = 0x15 for the above screen shot.

Visit and get value from numArray[i] by adding the $4i$ and the base address of array. The address of the value is $\$t5$. Load the value into $\$a0$ for further execution.

### 5.3 switch case

Regard three cases as three blocks. If the case condition is met by the current CntType, jump to the relevant block. Otherwise, it will continue to judge whether the program can jump to the next "case" block. Line 92-117 in project1.s

After executing function described in 5.4 respectively, whatever block jump to, it will return to the for loop block $countArrayFor$. Add the result of the function in 5.4 into $cnt$. Then continues the next loop. Line 120-124 in project1.s. In this screenshot, i = 0x25, cntType = 1.

~~~c
switch (cntType) {
            case 1 : cnt += Pos(A[i]); break;
            case -1: cnt += Neg(A[i]); break;
            default: 
                cnt += Zero(A[i]);
                break;
        }
~~~



![1569608627779](D:\OneDrive - sjtu.edu.cn\JI\2019FA\VE370\PROJECT1\1569608627779.png)

### 5.4 Pos(int), Neg(int), Zero(int)

Refer to code block, Line 134- 162 in source code for details.

~~~c
int Pos(int x) {
    if(x>0) return 1;
    else return 0;
}

int Neg(int x) {
    if (x<0) return 1;
    else return 0;
}

int Zero(int x) {
    if (x==0) return 1;
    else return 0;
}
~~~



### 5.5 End of for loop then end of the function

Line 126-132 in project1.s.

Set the result register $\$v0$ from result variable stored in $\$t9$.

Load the return address saved at the beginning of the function and return to main.

~~~c
return cnt;
~~~



![1569609660854](D:\OneDrive - sjtu.edu.cn\JI\2019FA\VE370\PROJECT1\1569609660854.png)

## 6. Screenshot after the first, second, third call of countArray(int*,int,int)

~~~C
PosCnt = countArray(testArray, size, 1);
NegCnt = countArray(testArray, size, -1);
ZeroCnt = countArray(testArray, size, 0);
~~~

### 6.1 After the first call

![1569603981790](D:\OneDrive - sjtu.edu.cn\JI\2019FA\VE370\PROJECT1\1569603981790.png)

Notice that $\$s1$=9. PosCnt = 9.It is the correct answer.

### 6.2 After the second call

![1569605036318](D:\OneDrive - sjtu.edu.cn\JI\2019FA\VE370\PROJECT1\1569605036318.png)

Notice that $\$s2$=9.  NegCnt = 9. It is the correct answer.

### 6.3 After the third call

![1569605438156](D:\OneDrive - sjtu.edu.cn\JI\2019FA\VE370\PROJECT1\1569605438156.png)

Notice that $\$s3$=3.  ZeroCnt = 3. It is the correct answer.

## 7. Exit

![1569608805707](D:\OneDrive - sjtu.edu.cn\JI\2019FA\VE370\PROJECT1\1569608805707.png)

## 8. Conclusion

In this project, we successfully practice the transformation from C language to MIPS assembly language. 

Without delay operation, I countered some unexpected errors or bugs during simulation . After adding delay operations for some $jal$ commands, such bugs are fixed. I wonder if there is explanation or related knowledge about this phenomenon.  Since the part of code for loading 21 variables into $\$sp$ stack is completed by C++ program, I think there may exist better or senior usage of the assembly language to store an array. 



## Appendix

Array generation

~~~python
import random
size = 21
arr = []
for i in range(0, size):
    arr.append(random.randint(-40, 40))
print(arr)

~~~

project1.s

~~~asm
.text
.globl __start
__start:
    addi $s0,$0,21  #int size = 21
    addi $sp,$sp,-84 #stack for 21*4 items
    
    addu $s1,$0,$0 # int PosCnt = 0
    addu $s2,$0,$0 # int NegCnt = 0
    addu $s3,$0,$0 # int ZeroCnt = 0
    
    addi $t0, $0, 14 # store 1st temporarily in $t0
    sw $t0, 0($sp) #store in testArray[0]
    addi $t0, $0, -15 # store 2nd temporarily in $t0
    sw $t0, 4($sp) #store in testArray[1]
    addi $t0, $0, 0 # store 3th temporarily in $t0
    sw $t0, 8($sp) #store in testArray[2]
    addi $t0, $0, -13 # store 4th temporarily in $t0
    sw $t0, 12($sp) #store in testArray[3]
    addi $t0, $0, -8 # store 5th temporarily in $t0
    sw $t0, 16($sp) #store in testArray[4]
    addi $t0, $0, 16 # store 6th temporarily in $t0
    sw $t0, 20($sp) #store in testArray[5]
    addi $t0, $0, 30 # store 7th temporarily in $t0
    sw $t0, 24($sp) #store in testArray[6]
    addi $t0, $0, -38 # store 8th temporarily in $t0
    sw $t0, 28($sp) #store in testArray[7]
    addi $t0, $0, 24 # store 9th temporarily in $t0
    sw $t0, 32($sp) #store in testArray[8]
    addi $t0, $0, 0 # store 10th temporarily in $t0
    sw $t0, 36($sp) #store in testArray[9]
    addi $t0, $0, 18 # store 11st temporarily in $t0
    sw $t0, 40($sp) #store in testArray[10]
    addi $t0, $0, 14 # store 12nd temporarily in $t0
    sw $t0, 44($sp) #store in testArray[11]
    addi $t0, $0, -30 # store 13th temporarily in $t0
    sw $t0, 48($sp) #store in testArray[12]
    addi $t0, $0, -13 # store 14th temporarily in $t0
    sw $t0, 52($sp) #store in testArray[13]
    addi $t0, $0, -2 # store 15th temporarily in $t0
    sw $t0, 56($sp) #store in testArray[14]
    addi $t0, $0, 17 # store 16th temporarily in $t0
    sw $t0, 60($sp) #store in testArray[15]
    addi $t0, $0, 0 # store 17th temporarily in $t0
    sw $t0, 64($sp) #store in testArray[16]
    addi $t0, $0, -27 # store 18th temporarily in $t0
    sw $t0, 68($sp) #store in testArray[17]
    addi $t0, $0, 11 # store 19th temporarily in $t0
    sw $t0, 72($sp) #store in testArray[18]
    addi $t0, $0, -30 # store 20th temporarily in $t0
    sw $t0, 76($sp) #store in testArray[19]
    addi $t0, $0, 25 # store 21st temporarily in $t0
    sw $t0, 80($sp) #store in testArray[20]

    addu $a0,$0,$sp # a0 = testArray
    addu $a1,$0,$s0 # a1 = size
    addi $a2,$0,1 # a2 = 1
    jal countArray # $v0 = countArray(testArray, size, 1)
    addi $t0, $0, 1  # wait for delay
    addu $s1,$v0,$0 # PosCnt = $v0

    addu $a0,$0,$sp # a0 = testArray
    addu $a1,$0,$s0 # a1 = size
    addi $a2,$0,-1 # a2 = -1
    jal countArray # $v0 = countArray(testArray, size, -1)
    addi $t0, $0, 1  # wait for delay
    add $s2, $v0, $0 # NegCnt = $v0

    addu $a0,$0,$sp # a0 = testArray
    addu $a1,$0,$s0 # a1 = size
    addi $a2,$0,0 # a2 = 0
    jal countArray # $v0 = countArray(testArray, size, 0)
    addi $t0, $0, 1  # wait for delay
    add $s3, $v0, $0 # ZeroCnt = $v0
    jal exit # exit

countArray:
    sw $ra, 84($sp) # save ra into the stack
    addu $t0,$a1,$0 # save $a1(numElements) into $t0
    addu $t1,$a2,$0 # save $a2(cntType) into $t1
    addi $t3,$t0,-1 # t3(i) = numElements - 1
    add $t9, $0,0 # cnt = 0

countArrayFor:
    addi $t0, $0, 1  # wait for delay
    slt $t4,$t3,$0 # t4 = i < 0
    bne $t4,$0,countArrayForEnd # if (i< 0 == 1), the loop ends, go to ForEnd
    sll $t5,$t3,2 # t5 = t3*4
    add $t5,$t5,$sp # t5 =array + t5
    lw $a0,0($t5) # a0 = testArray[i]
    add $t2, $0,1 # t2 = 1
    addi $t0, $0, 1  # wait for delay
    beq $t1,$t2,Case1 #if(cntType == 1) go to Case 1
    addi $t0, $0, 1  # wait for delay
    add $t2,$0,-1 # t2 = -1
    beq $t1,$t2,CaseM1 #if(cntType == -1) go to Case M1(-1)
    addi $t0, $0, 1  # wait for delay
    beq $t1,$0, Case0 #if(cntType == 0) go to Case 0
    j countArrayEsac # jump to end of case
    addi $t0, $0, 1  # wait for delay

Case1:
    jal Pos #v0 = Pos(array[i])
    addi $t0, $0, 1  # wait for delay
    j countArrayEsac # break; jump to end of case
    addi $t0, $0, 1  # wait for delay

CaseM1:
    jal Neg #v0 = Neg(array[i])
    addi $t0, $0, 1  # wait for delay
    j countArrayEsac # break; jump to end of case
    addi $t0, $0, 1  # wait for delay

Case0:
    jal Zero #v0 = Zero(array[i])
    addi $t0, $0, 1  # wait for delay
    j countArrayEsac # break; jump to end of case
    addi $t0, $0, 1  # wait for delay

countArrayEsac:
    addu $t9,$t9,$v0 # cnt+=v0
    add $v0,$0,$0 # reset v0 to 0
    addi $t3,$t3,-1 # i--
    j countArrayFor # next loop
    addi $t0, $0, 1  # wait for delay

countArrayForEnd:
    addi $t0, $0, 1  # wait for delay
    addu $v0,$0,$t9 # v0 = cnt
    lw $ra,84($sp) #recover ra from the stack
    addi $t0, $0, 1  # wait for delay
    jr $ra # return 
    addi $t0, $0, 1  # wait for delay

Pos:
    slt $t5, $0, $a0       # $t5 = 0 < x
    bne $t5, $0, PosIf     # if ($t5 == 1) go to PosIf
    addi $v0, $0, 0         # $v0 = 0
    jr $ra                  # return
    addi $t0, $0, 1  # wait for delay
PosIf:
    addi $v0, $0, 1         # $v0 = 1
    jr $ra                  # return
    addi $t0, $0, 1  # wait for delay
    
Neg:
    slt $t5, $a0, $0       # $t5 = x < 0
    bne $t5, $0, NegIf     # if ($t5 == 1) go to NegIf
    addi $v0, $0, 0         # $v0 = 0
    jr $ra                  # return
    addi $t0, $0, 1  # wait for delay
NegIf:
    addi $v0, $0, 1         # $v0 = 1
    jr $ra                  # return
    addi $t0, $0, 1  # wait for delay
Zero:
    beq $a0, $0, ZeroIf     # if ($a0 == 0) go to ZeroIf
    addi $v0, $0, 0         # $v0 = 0
    jr $ra                  # return
    addi $t0, $0, 1  # wait for delay
ZeroIf:
    addi $v0, $0, 1         # $v0 = 1
    jr $ra                  # return
    addi $t0, $0, 1  # wait for delay

exit:
    addi $v0, $0, 10        # prepare to exit (system call 10)
    syscall                 # exit
~~~

